# Parser API Reference

This document provides detailed API documentation for the dvSQL parser functions and interfaces.

## Overview

The dvSQL parser converts SQL statements into Abstract Syntax Trees (AST). It uses yacc/bison for grammar parsing and flex for lexical analysis.

## Core Parser Functions

### `int yyparse()`
Main parsing function generated by yacc/bison.

**Returns:**
- `0` on successful parse
- `1` on parse error

**Usage:**
```c
extern FILE* yyin;
extern ast_node_t* ast_root;

yyin = fopen("query.sql", "r");
if (yyparse() == 0) {
    // Parse successful, AST available in ast_root
    print_ast(ast_root, 0);
    free_ast(ast_root);
}
```

### `void yyerror(const char* s)`
Error handling function called by parser on syntax errors.

**Parameters:**
- `s`: Error message string

**Behavior:**
- Prints error message with line number and current token
- Called automatically by yacc/bison on parse errors

## AST Creation Functions

### Statement Creation

#### `ast_node_t* create_select_stmt(column_list_t* columns, table_ref_t* from_table)`
Creates a SELECT statement AST node.

**Parameters:**
- `columns`: List of columns to select
- `from_table`: Table reference for FROM clause

**Returns:** Pointer to new AST node or NULL on allocation failure

**Example:**
```c
// For: SELECT name, age FROM users;
expression_t* name_expr = create_identifier_expr("name");
expression_t* age_expr = create_identifier_expr("age");
column_list_t* columns = create_column_list(name_expr);
add_column_to_list(&columns, age_expr);
table_ref_t* from_table = create_table_ref("users", NULL);
ast_node_t* select_stmt = create_select_stmt(columns, from_table);
```

#### `ast_node_t* create_insert_stmt(char* table_name, column_list_t* columns, value_list_t* values)`
Creates an INSERT statement AST node.

**Parameters:**
- `table_name`: Target table name
- `columns`: Column list (NULL for INSERT without explicit columns)
- `values`: List of values to insert

**Returns:** Pointer to new AST node or NULL on allocation failure

#### `ast_node_t* create_update_stmt(char* table_name, column_list_t* set_columns, value_list_t* set_values, expression_t* where_clause)`
Creates an UPDATE statement AST node.

**Parameters:**
- `table_name`: Target table name
- `set_columns`: Columns being updated
- `set_values`: New values for columns
- `where_clause`: WHERE condition (NULL if none)

**Returns:** Pointer to new AST node or NULL on allocation failure

#### `ast_node_t* create_delete_stmt(char* table_name, expression_t* where_clause)`
Creates a DELETE statement AST node.

**Parameters:**
- `table_name`: Target table name
- `where_clause`: WHERE condition (NULL if none)

**Returns:** Pointer to new AST node or NULL on allocation failure

#### `ast_node_t* create_create_table_stmt(char* table_name, column_def_t* columns)`
Creates a CREATE TABLE statement AST node.

**Parameters:**
- `table_name`: New table name
- `columns`: Column definitions

**Returns:** Pointer to new AST node or NULL on allocation failure

#### `ast_node_t* create_drop_table_stmt(char* table_name)`
Creates a DROP TABLE statement AST node.

**Parameters:**
- `table_name`: Table to drop

**Returns:** Pointer to new AST node or NULL on allocation failure

### Expression Creation

#### `expression_t* create_identifier_expr(char* identifier)`
Creates an identifier expression.

**Parameters:**
- `identifier`: Identifier string (duplicated internally)

**Returns:** Pointer to new expression or NULL on allocation failure

#### `expression_t* create_literal_expr(literal_value_t value, int literal_type)`
Creates a literal expression.

**Parameters:**
- `value`: Literal value union
- `literal_type`: Type of literal (INTEGER_LITERAL, STRING_LITERAL, etc.)

**Returns:** Pointer to new expression or NULL on allocation failure

#### `expression_t* create_binary_op_expr(expression_t* left, expression_t* right, int operator)`
Creates a binary operation expression.

**Parameters:**
- `left`: Left operand expression
- `right`: Right operand expression
- `operator`: Operator token (PLUS, EQUAL, AND, etc.)

**Returns:** Pointer to new expression or NULL on allocation failure

#### `expression_t* create_unary_op_expr(expression_t* operand, int operator)`
Creates a unary operation expression.

**Parameters:**
- `operand`: Operand expression
- `operator`: Operator token (NOT, MINUS)

**Returns:** Pointer to new expression or NULL on allocation failure

#### `expression_t* create_function_call_expr(char* function_name, expression_t** args, int arg_count)`
Creates a function call expression.

**Parameters:**
- `function_name`: Function name string (duplicated internally)
- `args`: Array of argument expressions
- `arg_count`: Number of arguments

**Returns:** Pointer to new expression or NULL on allocation failure

#### `expression_t* create_column_ref_expr(char* table_name, char* column_name)`
Creates a column reference expression.

**Parameters:**
- `table_name`: Table name (NULL if not qualified, duplicated internally)
- `column_name`: Column name (duplicated internally)

**Returns:** Pointer to new expression or NULL on allocation failure

### List Creation and Manipulation

#### `column_list_t* create_column_list(expression_t* column)`
Creates a new column list with one column.

**Parameters:**
- `column`: Initial column expression

**Returns:** Pointer to new column list or NULL on allocation failure

#### `void add_column_to_list(column_list_t** list, expression_t* column)`
Adds a column to the end of a column list.

**Parameters:**
- `list`: Pointer to column list pointer
- `column`: Column expression to add

#### `value_list_t* create_value_list(expression_t* value)`
Creates a new value list with one value.

**Parameters:**
- `value`: Initial value expression

**Returns:** Pointer to new value list or NULL on allocation failure

#### `void add_value_to_list(value_list_t** list, expression_t* value)`
Adds a value to the end of a value list.

**Parameters:**
- `list`: Pointer to value list pointer
- `value`: Value expression to add

#### `table_ref_t* create_table_ref(char* table_name, char* alias)`
Creates a table reference.

**Parameters:**
- `table_name`: Table name (duplicated internally)
- `alias`: Table alias (NULL if none, duplicated internally)

**Returns:** Pointer to new table reference or NULL on allocation failure

#### `column_def_t* create_column_def(char* column_name, data_type_t data_type)`
Creates a column definition for CREATE TABLE.

**Parameters:**
- `column_name`: Column name (duplicated internally)
- `data_type`: SQL data type

**Returns:** Pointer to new column definition or NULL on allocation failure

## Output and Debugging Functions

### `void print_ast(ast_node_t* node, int indent)`
Pretty-prints an AST node with proper indentation.

**Parameters:**
- `node`: AST node to print
- `indent`: Indentation level (0 for root)

**Example:**
```c
print_ast(ast_root, 0);
```

**Output format:**
```
SELECT name, age
FROM users
WHERE age > 18
```

## Memory Management Functions

### `void free_ast(ast_node_t* node)`
Recursively frees an entire AST and all its children.

**Parameters:**
- `node`: Root AST node to free

**Usage:**
```c
// Always free AST when done
if (ast_root) {
    free_ast(ast_root);
    ast_root = NULL;
}
```

### `void free_expression(expression_t* expr)`
Recursively frees an expression tree.

**Parameters:**
- `expr`: Expression to free

### List Memory Management
- `void free_column_list(column_list_t* list)`
- `void free_value_list(value_list_t* list)`
- `void free_table_ref(table_ref_t* ref)`
- `void free_join_clause(join_clause_t* clause)`
- `void free_column_def(column_def_t* def)`

## Global Variables

### `ast_node_t* ast_root`
Global variable containing the root of the parsed AST.

**Usage:**
- Set by parser after successful parse
- Must be freed by caller using `free_ast()`
- NULL if no valid parse or parse failed

### `extern FILE* yyin`
Input file stream for lexer/parser.

**Usage:**
```c
yyin = fopen("query.sql", "r");
yyparse();
fclose(yyin);
```

### `extern int yylineno`
Current line number in input.

**Usage:**
- Automatically maintained by lexer
- Used in error reporting
- Reset to 1 at start of parsing

## Error Handling

### Parse Errors
When `yyparse()` encounters a syntax error:
1. Calls `yyerror()` with error message
2. Prints error with line number and current token
3. Returns 1 to indicate failure
4. `ast_root` remains NULL or undefined

### Memory Allocation Errors
AST creation functions return NULL on allocation failure:
```c
ast_node_t* node = create_select_stmt(columns, from_table);
if (!node) {
    fprintf(stderr, "Memory allocation failed\n");
    // Handle error appropriately
}
```

## Usage Examples

### Basic Parsing
```c
#include "ast.h"
#include "tokens.h"

extern FILE* yyin;
extern int yyparse();
extern ast_node_t* ast_root;

int main() {
    yyin = fopen("query.sql", "r");
    if (!yyin) {
        perror("Cannot open file");
        return 1;
    }
    
    if (yyparse() == 0) {
        printf("Parse successful!\n");
        print_ast(ast_root, 0);
        free_ast(ast_root);
    } else {
        printf("Parse failed!\n");
    }
    
    fclose(yyin);
    return 0;
}
```

### Parsing from String
```c
#include <string.h>

int parse_string(const char* sql) {
    FILE* temp = tmpfile();
    if (!temp) return -1;
    
    fwrite(sql, 1, strlen(sql), temp);
    rewind(temp);
    
    yyin = temp;
    int result = yyparse();
    fclose(temp);
    
    return result;
}
```

## See Also

- [AST Node Types](ast.md)
- [Token Types](tokens.md)
- [Grammar Definition](../technical/grammar.md)
- [Parser Design](../technical/parser-design.md)